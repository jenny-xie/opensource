#+TITLE: propositum | =WINDOWS=
#+PROPERTY: header-args :tangle yes
#+OPTIONS: prop:t
[[https://img.shields.io/github/tag/xeijin/propositum.svg?label=release&style=flat-square]] [[https://ci.appveyor.com/project/xeijin/propositum][https://img.shields.io/appveyor/ci/xeijin/propositum.svg?style=flat-square&logo=appveyor&label=build]] [[https://img.shields.io/badge/license-GPLv3-red.svg?style=flat-square]]

#+BEGIN_QUOTE
A collection of free and open-source, portable tools to facilitate task & information management, automation, data manipulation and analytics.
#+END_QUOTE

* Usage :README:
:PROPERTIES:
:ID:       91341445-2039-42FC-9E73-9996D38AC962
:END:

Installation via the [[https://gitlab.com/xeijin/propositum/releases][Releases]] for the latest binary distribution. Unzip, then ensure you run
the post-install ps1 script.

#+BEGIN_SRC powershell
### --- NOTE: If you are reading from the PS1 script you will find documentation sparse, --- ###
### --- this script is accompanied by an org-mode file used to literately generate it.   --- ###
### --- Please see https://gitlab.com/xeijin-dev/propositum for the accompanying README.org  --- ###
#+END_SRC
* Define
Define key [[Components]] and [[Variables]]
** Literate Functions

The list of [[Components]] and their attributes, as well as user-defined [[Variables]] are both maintained in an [[https://orgmode.org/manual/Tables.html][org-mode tables]]. Using [[https://orgmode.org/worg/org-contrib/babel/][org-babel]] and some elisp the contents of these tables are actually executed by PowerShell for use in scripts.

This makes it easier to add new components and variables, as well as modify the existing attributes of these items. It also helps us segregate user-defined inputs from functions, making debugging easier and our code (hopefully) cleaner.
*** Start in the script folder

This is required for most of the literate functions to work correctly

#+BEGIN_SRC powershell
  cd $psScriptRoot
#+END_SRC
*** Require elisp dependencies
:PROPERTIES:
:ID:       1124209E-CC37-405E-80A0-9466D7FA0FF9
:END:

First, let's ensure we get any required elisp dependencies

#+BEGIN_SRC elisp
  (require 'org)
  ;(require 'json)
#+END_SRC
*** Import from CSV
:PROPERTIES:
:ID:       BA24D132-E2E5-4603-B856-E804B744B5FE
:END:

Now define an org-babel source code block to /import/ variables from an existing =CSV= file, into an org-mode table. It takes a single argument, the path to the =CSV= file as a string.

#+NAME: org-babel-tbl-import-csv
#+BEGIN_SRC elisp
  (with-temp-buffer
    (org-table-import csv-path nil) ;; MEMO on `nil' arg is in the footnotes.
    (setq LST (org-table-to-lisp))
    ;; comment out or cut below one line if you don't have column names in CSV file.
    (append (list (car LST)) '(hline) (cdr (org-table-to-lisp))))
#+END_SRC
*** Export to CSV
:PROPERTIES:
:ID:       FC1EE611-609C-4AB4-9BFC-1B27898BCC88
:END:

We also need to define an org-babel source block to export an org-mode table back to a =CSV=.

It takes two arguments, the path to the =CSV= file, and also a name for the org-mode table it generates. Both should be a =string=.

#+NAME: org-babel-tbl-export-csv
#+BEGIN_SRC elisp
  (save-excursion
    (org-open-link-from-string (concat "[[" tbl-name "]]"))
    (while (not (org-table-p)) (forward-line))
    (org-table-export csv-path "orgtbl-to-csv"))
#+END_SRC
*** Export Tagged subtrees to ORG (for README)

Used to create a succinct README.org file for =GitLab= and others.

#+NAME: export-tagged-subtrees-org
#+BEGIN_SRC elisp :var tagname="README" outputdir="../"
(let ((org-export-select-tags (list tagname)) (async nil) (subtreep nil) (visible-only nil) (body-only nil) (ext-plist '())) 
               (org-export-to-file 'org (concat outputdir tagname ".org") async subtreep visible-only body-only ext-plist))
#+END_SRC

#+RESULTS: export-tagged-subtrees-org
: ../README.org
** Components :README:
:PROPERTIES:
:ID:       741E70D9-49CC-4E90-89B0-8B30F110DB46
:END:
  
Next, within the table, define the environment variables and their desired values

#+NAME: components-tbl
#+RESULTS: components-import
| component                | license                          | usage                                                                    | categorisation                                               |
|--------------------------+----------------------------------+--------------------------------------------------------------------------+--------------------------------------------------------------|
| [[http://cmder.net/][Cmder]]                    | [[https://github.com/cmderdev/cmder#license][MIT]]                              | console emulator & cmd replacement                                       | Standalone Tool                                              |
| [[https://www.gnu.org/software/emacs/][emacs]] & [[https://orgmode.org/][org-mode]]         | [[https://github.com/zklhp/emacs-w64/blob/emacs-25/COPYING][GPL-3.0]]                          | task & information management, text editor, IDE, composing documentation | Loosely Coupled with internal code (e.g. internal REST APIs) |
| [[https://github.com/hlissner/doom-emacs][doom-emacs]]               | [[https://github.com/hlissner/doom-emacs/blob/master/LICENSE][MIT]]                              | configuration framework for emacs                                        | Loosely Coupled with internal code (e.g. internal REST APIs) |
| [[https://autohotkey.com/][AutoHotKey]]               | [[https://github.com/Lexikos/AutoHotkey_L/blob/master/license.txt][GPL-2.0]]                          | general Windows automation, expanding commonly used text snippets        | Standalone Tool                                              |
| [[https://www.knime.com/knime-analytics-platform][KNIME Analytics Platform]] | [[https://www.knime.com/downloads/full-license][GPL-3.0]]                          | data pipelines, transformation, automation & reporting                   | Loosely Coupled with internal code (e.g. internal REST APIs) |
| [[http://rawgraphs.io/][RAWGraphs]]                | [[https://github.com/densitydesign/raw/blob/master/LICENSE][Apache-2.0]]                       | data visualisation                                                       | Standalone Tool                                              |
| [[https://superset.incubator.apache.org/][Apache Superset]]          | [[https://github.com/apache/incubator-superset/blob/master/LICENSE.txt][Apache-2.0]]                       | data exploration, dashboards & data visualisation                        | Standalone Tool                                              |
| [[https://pandoc.org/][Pandoc]]                   | [[https://github.com/jgm/pandoc/blob/master/COPYRIGHT][GPL-2.0]]                          | convert between many different document types                            | Standalone Tool                                              |
| [[https://www.imagemagick.org/][ImageMagick]]              | [[https://imagemagick.org/script/license.php][ImageMagick]] (GPL-3.0 compatible) | convert between different image formats                                  | Standalone Tool                                              |
| [[https://www.listary.com/text-editor-anywhere][Text Editor Anywhere]]     | [[https://www.listary.com/text-editor-anywhere][Freeware]]                         | use emacs to edit text in any text field                                 | Standalone Tool                                              |
| [[http://plantuml.com/][PlantUML]]                 | [[https://github.com/plantuml/plantuml/blob/master/license.txt][GPL-3.0]]                          | create diagrams using text descriptions                                  | Standalone Tool                                              |

We can export to ~components.csv~ for use e.g. by PowerShell

#+NAME: components-export
#+CALL: org-babel-tbl-export-csv(csv-path="components.csv", tbl-name="components-tbl")

#+RESULTS: components-export
** Variables :README:
*** Platform-specific variables & secrets

 Use =#+CALL:= once again to import our variables defined in ~vars-platform.csv~

 =IMPORT= =IMPORT= =IMPORT=
 #+NAME: vars-platform-import
 #+CALL: org-babel-tbl-import-csv(csv-path="vars-platform.csv")
 =IMPORT= =IMPORT= =IMPORT=

 Define the environment variables and their desired values in the table

 - note that for AppVeyor some of these are defined in the UI as secrets, but when we run the script locally we will need to securely collect these from the user
 - Remember *not* to include a ~$~ before the variable name in the =var= column of the table. The ~New-Variable~ command will add this in upon execution
 - Important to specify =assign= or =execute= values, otherwise =iex= can cause undesired behaviour (e.g. trying to evaluate a path that doesn't exist instead of assigning)

Then populate with the variable names, which will be executed by
=Invoke-Expression= (aka =iex=).

 #+NAME: vars-platform-tbl
 #+RESULTS: vars-platform-import
 | type   | exec    | var                    | appveyor              | local                                                                                                                                             | local-gs                                                                                                                                          | testing                                                                                                                                           | comment                                                                       |
 |--------+---------+------------------------+-----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------|
 | normal | assign  | env:propositumLocation | C:\propositum         | C:\propositum                                                                                                                                     | H:\propositum                                                                                                                                     | C:\propositum-test                                                                                                                                | The =git clone= location of the propositum repo                               |
 | normal | execute | env:propositumDrv      | $env:propositumDrv    | (& {if(($result = Read-Host 'Please provide a letter for the Propositum root drive (default is ‘P').') -eq ‘’){‘P:’}else{$result.Trim(‘;’)+’:’}}) | (& {if(($result = Read-Host 'Please provide a letter for the Propositum root drive (default is ‘P').') -eq ‘’){‘P:’}else{$result.Trim(‘;’)+’:’}}) | (& {if(($result = Read-Host 'Please provide a letter for the Propositum root drive (default is ‘P').') -eq ‘’){‘P:’}else{$result.Trim(‘;’)+’:’}}) | The drive letter =$propositumLocation= will map to                            |
 | secure | execute | env:supersetPassword   | $env:supersetPassword | (& {Read-Host -AsSecureString 'Please provide a password for the Superset user ‘Propositum’.’})                                                   | (& {Read-Host -AsSecureString 'Please provide a password for the Superset user ‘Propositum’.’})                                                   | (& {Read-Host -AsSecureString 'Please provide a password for the Superset user ‘Propositum’.’})                                                   | The password for the =propositum= user for the =superset= application         |

 Then export to ~vars-platform.csv~

 =EXPORT= =EXPORT= =EXPORT=
 #+NAME: vars-platform-export
 #+CALL: org-babel-tbl-export-csv(csv-path="vars-platform.csv", tbl-name="vars-platform-tbl")
 =EXPORT= =EXPORT= =EXPORT=

 #+RESULTS: vars-platform-export
 : Export done.
*** Other variables

We need to define a few key paths and other variables which will be referred to regularly throughout the coming scripts, but are not platform specific. 

Let's import these from =vars-other.csv=

=IMPORT= =IMPORT= =IMPORT=
#+NAME: vars-other-import
#+CALL: org-babel-tbl-import-csv(csv-path="vars-other.csv")
=IMPORT= =IMPORT= =IMPORT=

Then lets define them in a simplified table

#+NAME: vars-other-tbl
 #+RESULTS: vars-other-import
 | type    | exec    | var             | value                      | comment                                                        |
 |---------+---------+-----------------+----------------------------+----------------------------------------------------------------|
 | hsh-tbl | execute | propositum      | @{}                        | Initialises the hash table                                     |
 | hsh-itm | execute | propositum.root | $env:propositumDrv+"\"     | Propositum root folder                                         |
 | hsh-itm | execute | propositum.apps | $env:propositumDrv+"\apps" | Propositum apps folder (scoop root)                            |
 | hsh-itm | execute | propositum.home | $env:propositumDrv+"\home" | Propositum home folder (dotfiles & projects)                   |
 | hsh-itm | execute | propositum.font | $env:propositumDrv+"\font" | Propositum fonts folder                                        |
 | env-var | execute | env:HOME        | $propositum.home           | Sets env-var home to propositum home                           |
 | env-var | execute | env:SCOOP       | $propositum.root           | Sets scoop home to the propositum root (creates 'apps' folder) |


*Note:* The ~type~ column here is important, particularly =hsh-itm= & =env-var=.

Finally, export the table back to csv

 =EXPORT= =EXPORT= =EXPORT=
 #+NAME: vars-other-export
 #+CALL: org-babel-tbl-export-csv(csv-path="vars-other.csv", tbl-name="vars-other-tbl")
 =EXPORT= =EXPORT= =EXPORT=

 #+RESULTS: vars-other-export
 : Export done.
*** Import into PowerShell
As some of the variables are dependent on other build environment functions this section has been moved: [[Import functions & variables]]
* Prepare
Obtain any required tools, initialise variables & setup the build environment
** Set mode & determine build platform
:PROPERTIES:
:ID:       18FAC438-1875-4EE9-96F2-39EB5D0C1B6E
:END:

Add a variable to allow us to switch to testing / development mode - this will use the variable assignments in the "testing" column when we come to our [[Variables]].

#+BEGIN_SRC powershell
$testing = $false
#+END_SRC

Figure out if the script is being run from a local machine, from gs machine or on appveyor, or if we're testing/debugging

#+NAME: set-build-platform
#+BEGIN_SRC powershell
  $buildPlatform = if ($env:APPVEYOR) {"appveyor"}
  elseif ($testing) {"testing"} # For debugging locally
  elseif ($env:computername -match "NDS.*") {"local-gs"} # Check for NDS
  else {"local"}
#+END_SRC
** Initialise Environment
:PROPERTIES:
:ID:       84C36059-E29F-439D-AF82-732D3146F219
:END:
Ensure the necessary tooling is in place & prepare the build environment.
*** Start in the Script Root
:PROPERTIES:
:ID:       772511DD-7D6F-486F-9F2C-8BC128CDA391
:END:

Make sure we start in the script root to avoid issues with executing in the wrong directory & to ensure we can access any scripts or data structures that we need to import.

#+BEGIN_SRC powershell
  cd $PSScriptRoot
#+END_SRC
*** Console formatting
:PROPERTIES:
:ID:       0372ECBA-729F-4B3D-961D-661B18CAC4C5
:END:

Turn the PowerShell background color to Black to make blue output from commands easier to read

#+BEGIN_SRC powershell
  $Host.UI.RawUI.BackgroundColor = ($bckgrnd = 'Black')
#+END_SRC
*** Helper functions
:PROPERTIES:
:header-args: :tangle propositum-helper-fns.ps1
:END:

Define helper functions to perform repetitive activities
**** ~Path-CheckOrCreate~: Check for path and optionally create dir or symlink
:PROPERTIES:
:ID:       DA8B2429-3EB2-4784-81B1-F69152B9253A
:END:

Check if a dir exists, and if specified, create the directory (or symlink)

#+BEGIN_SRC powershell
  function Path-CheckOrCreate {

  # Don't make parameters positionally-bound (unless explicitly stated) and make the Default set required with all
  [CmdletBinding(PositionalBinding=$False,DefaultParameterSetName="Default")]

      # Define Parameters incl. defaults, types & validation
      Param(
          # Allow an array of strings (paths)
          [Parameter(Mandatory,ParameterSetName="Default")]
          [Parameter(Mandatory,ParameterSetName="CreateDir")]
          [Parameter(Mandatory,ParameterSetName="CreateSymLink")]
          [string[]]$paths,

          # Parameter sets to allow either/or but not both, of createDir and createSymLink. createSymLink is an array of strings to provide the option of matching with multiple paths.
          [Parameter(ParameterSetName="CreateDir",Mandatory=$false)][switch]$createDir,
          [Parameter(ParameterSetName="CreateSymLink",Mandatory=$false)][string[]]$createSymLink = @() # Default value is an empty array to prevent 'Cannot index into null array'
     )

      # Create Arrs to collect the directories that exist/don't exist
      $existing = @()
      $notExisting = @()
      $existingSymLink = @()
      $notExistingSymLink = @()
      $createdDir = @()
      $createdSymLink = @()

      # Loop through directories in $directory
      for ($i = 0; $i -ne $paths.Length; $i++)
      {

          # If exists, add to existing, else add to not existing
          if (Test-Path $paths[$i]) 
          {
              $existing += , $paths[$i]
              continue
          }
          else {$notExisting += , $paths[$i]}

          # If any symlinks have been provided, also do a check to see if these exist
          if ( ($createSymLink[$i]) -and (Test-Path $createSymLink[$i]) )
          {$existingSymLink += , $createSymLink[$i]}
          else {$notExistingSymLink += , $createSymLink[$i]}

          # Next, check if valid path
          if (Test-Path -Path $paths[$i] -IsValid)
          {
              # If user wants to create the directory, do so
              if ($createDir)
              {
                  if (mkdir $paths[$i]) {$createdDir += , $paths[$i]}
              }
              # If user wants to create a symbolic link, do so
              elseif ($createSymlink)
              {
              if(New-Item -ItemType SymbolicLink -Value $paths[$i] -Path $createSymLink[$i]) # Use the counter to select the right Symlink value
                  {$createdSymLink += , $createSymLink[$i]}
              }
          }
          else {Throw "An error occurred. Check the path is valid."}

      }

      # Write summary of directory operations to console [Turned off as annoying to see each time the command is run]
      #Write-Host "`n==========`n"
      #Write-Host "`n[Summary of Directory Operations]`n"
      #Write-Host "`nDirectories already exist:`n$existing`n"
      #Write-Host "`nDirectories that do not exist:`n$notExisting`n"
      #Write-Host "`nDirectories created:`n$createdDir`n"
      #Write-Host "`nSymbolic Links created:`n$createdSymLink`n"
      #Write-Host "`n==========`n"
    
      # Create a hash table of arrs, to access a given entry: place e.g. ["existing"] at the end of the expression
      # to get the arr value within add an index ref. e.g. ["existing"][0] for the first value within existing dirs
      $result = [ordered]@{
          existing = $existing
          existingSymLinks = $existingSymLink
          notExisting = $notexisting
          notExistingSymLinks = $notExistingSymLink
          createdDirs = $createdDir
          createdSymLinks = $createdSymLink
      }
    
      # Write results to the console
      Write-Host "`n================================="
      Write-Host "[Summary of Directory Operations]"
      Write-Host "=================================`n"
      Write-Host ($result | Format-Table | Out-String)
    
      return $result

  }
#+END_SRC
*** Import functions & variables
**** Import functions
:PROPERTIES:
:ID:       25BEA543-0DB2-4DE4-B099-34333F24516A
:END:

 Let's import the helper functions we defined earlier. Using the =.= notation means they will be imported with access to the variables in the current script scope.

 #+BEGIN_SRC powershell
   . ./propositum-helper-fns.ps1
 #+END_SRC
**** Import platform-specific variables
:PROPERTIES:
:ID:       538BDD23-6F58-424E-AC99-AB361C7B45E7
:END:

 We can now import ~vars-platform.csv~ we created earlier into PowerShell

 #+NAME: collect-platform-vars
 #+BEGIN_SRC powershell
   Try
   {
       $platformVars = Import-CSV "vars-platform.csv"
   }
   Catch
   {
       Throw "Check the CSV file actually exists and is formatted correctly before proceeding."
       $error[0]|format-list -force
   }
 #+END_SRC

 Finally, set each of the platform variables according to ~$buildPlatform~

 - ~Select~ is used to first narrow the ~PSObject~ to the column containing the variable name, and the column matching our buildPlatform
 - ~iex~ ensures that the value of each variable gets executed upon assignment, rather than being stored as a string
 - the ~if~ statement is used in conjunction with the =exec= column as mentioned earlier to avoid incorrectly executing a value that should be assigned

#+NAME: set-platform-vars
 #+BEGIN_SRC powershell
ForEach ($var in $platformVars | Select 'var', $buildPlatform, 'exec') { # Narrow to required columns & $buildPlatform
    if ($var.var -like "env:*") { # If variable name contains 'env:'
        if ($var.exec -eq 'execute') {Set-Item -Path $var.var -Value (iex $var.$buildPlatform)}  # If we need to 'execute'
        else {Set-Item -Path $var.var -Value $var.$buildPlatform} # Else just assign
    }
    else { # Logic for non-environment variables
        if ($var.exec -eq 'execute') {New-Variable $var.var (iex $var.$buildPlatform) -Force}
        else {New-Variable $var.var $var.$buildPlatform -Force}
    }
}
 #+END_SRC
**** Import other variables
:PROPERTIES:
:ID:       FE6574FA-0768-4A9E-826A-60EA8F8ECBD7
:END:
     
 Let's import the ~vars-other.csv~ into PowerShell

#+NAME: collect-other-vars
 #+BEGIN_SRC powershell
   Try
   {
       $otherVars = Import-CSV "vars-other.csv"
   }
   Catch
   {
       Throw "Check the CSV file actually exists and is formatted correctly before proceeding."
       $error[0]|format-list -force
   }
 #+END_SRC


=$env:= or environment variables are set in a different way to regular
variable, therefore we need some additional logic to handle those. Similarly for
=hsh-itm= entries, we don't want to try to assign as variables but actually add
the value to the corresponding hash table.


#+NAME: set-other-vars
#+BEGIN_SRC powershell
ForEach ($var in $otherVars) {
    if (($var.var -like "env:*") -or ($var.type -eq 'env-var')) { # If variable name contains 'env:', or is type 'env-var'
        if ($var.exec -eq "execute") {Set-Item -Path $var.var -Value (iex $var.value)} # If we need to 'execute'
        else {Set-Item -Path $var.var -Value $var.value} # Else just assign
    }
    elseif ($var.type -eq 'hsh-itm') { # Logic for hash table items
        $hsh = $var.var -split '\.' # Split the hash table item into a two-member array (note all hash table items must follow a hashtbl.keyname format)
        $hshtbl = iex ('$' + $hsh[0]) # Add '$' & define as hash table
        if ($var.exec -eq 'execute') {$hshtbl.add($hsh[1], (iex $var.value))}  # Add the key-value entry top the hash table: The first array entry is the hash table name, the second the name of the key
        else {$hshtbl.add($hsh[1], $var.value)}  # Same as above, but assign rather than invoke/execute the $var.value
    }
    else { # Logic for everything else (i.e. a regular variable)
        if ($var.exec -eq 'execute') {New-Variable $var.var (iex $var.value) -Force} 
        else {New-Variable $var.var $var.value -Force}
    }
}
#+END_SRC 

Calling the =$propositum= variable should now give us a hash table of paths

#+BEGIN_SRC powershell
$propositum | Format-Table | Out-String | Write-Host
#+END_SRC
*** Clear testing directory
:PROPERTIES:
:ID:       64FA9CC2-4B0E-436D-9EC4-E7E6B2BD50B7
:END:

To save some time, let's also delete the contents of the testing directory when in testing mode. 

We also add an additional condition to ensure that =$propositumLocation= has been set, otherwise we could end up deleting the root drive..

Note there's currently a powershell bug that prevents this from working if any symlinks are contained within the directories.

#+BEGIN_SRC powershell
  if ($testing -and $env:propositumLocation) {Remove-Item ($env:propositumLocation+"\*") -Recurse -Force}
#+END_SRC
*** Map propositum drive letter & create folder structure
:PROPERTIES:
:ID:       6DE0B5D0-189B-44BB-B418-201E8D8BD081
:END:
 
 Mapping the propositum folder to a drive letter creates a short, intuitive path to key directories

 #+NAME: map-propositum-drv
  #+BEGIN_SRC powershell
    subst $env:propositumDrv $env:propositumLocation
  #+END_SRC

  Now let's use the hash table we defined earlier in [[Other variables]], and loop through the paths; creating the directories where they don't already exist

  #+BEGIN_SRC powershell
    $createdDirs = Path-CheckOrCreate -Paths $propositum.values -CreateDir
  #+END_SRC

  Using the hash table of paths, we can now navigate to a given folder in the following manner

  #+BEGIN_SRC powershell
    cd $propositum.root
  #+END_SRC
*** Set TLS / SSL versions
:PROPERTIES:
:ID:       0356A598-F416-4B9E-AD32-DE71E9E0167B
:END:
This stops WebClient and other processes that require a secure connection from complaining if the connection requires a version other than TLS v1.0

#+BEGIN_SRC powershell
  [Net.ServicePointManager]::SecurityProtocol = "Tls12, Tls11, Tls, Ssl3"
#+END_SRC
** Install and configure =scoop=
*** Install =scoop=
:PROPERTIES:
:ID:       AC6E8709-BED1-4C65-9290-1D631C0CA7B0
:END:
    
[[https://scoop.sh][scoop]] is a bit like [[https://chocolatey.org][chocolatey]] but focused more on open source tools, and
importantly, allows you to install apps as self-contained 'units', as well as
creating handy manifests for your own apps / customm installs.

We already set the =$env:SCOOP= earlier in [[Other Variables]] so we can go ahead
and install scoop to that path

#+BEGIN_SRC powershell
  iex (new-object net.webclient).downloadstring('https://get.scoop.sh')
#+END_SRC
*** Add =extras= bucket
:PROPERTIES:
:ID:       E9337FC2-A9DB-4F26-8108-C6C44CC66F85
:END:

Add the =extras= bucket which contains some additional free or open source applications outside of the scope of the =main= scoop repo

#+BEGIN_SRC powershell
  scoop bucket add extras
#+END_SRC
*** Add =propositum= bucket
:PROPERTIES:
:ID:       074C0D8F-11F5-4C22-B992-422EA437C37D
:END:

Add the scoop =propositum= bucket which contains the JSON manifest files for installing and configuring the different propositum components.

#+BEGIN_SRC powershell
  scoop bucket add propositum 'https://gitlab.com/xeijin-dev/propositum-bucket.git'
#+END_SRC
** Clone =propositum= repo
:PROPERTIES:
:ID:       7895CDF9-52B1-4040-9FEC-1B4EE178C3A9
:END:

A number of required or source-controlled artifacts, including fonts, scripts and configuration files are already located in the propositum Repo, let's fetch those first

#+BEGIN_SRC powershell
git clone 'https://gitlab.com/xeijin-dev/propositum.git'
#+END_SRC
* Build 

Bring together the different components & create the final build artifact.
** Install components
:PROPERTIES:
:ID:       2B59D992-C445-439D-9C67-54554BBDBF7A
:END:

Use scoop to manage the installation of all components, including any
dependencies as defined in the component's manifest JSON.

Anything suffixed with a =-p= (for =propositum=) indicates a customised
manifest, likely doing something fairly specialised.

Use a powershell array to define the components to install (and for better readability)

#+NAME: propositum-components-list
#+BEGIN_SRC powershell
  $propositumComponents = @(
      'cmder',
      'lunacy',
      'autohotkey',
      'miniconda3',
      'imagemagick',
      'knime-p',
      'rawgraphs-p',
      'regfont-p',
      'emacs-p',
      'texteditoranywhere-p',
      'superset-p',
      'pandoc',
      'latex',
      'plantuml'
  )
#+END_SRC

Let the user know which components are being installed

#+BEGIN_SRC powershell
$componentsToInstall = $propositumComponents -join "`r`n=> " | Out-String
Write-Host "`r`nThe following components will be installed:`r`n`r`n=> $componentsToInstall" -ForegroundColor Black -BackgroundColor Yellow
#+END_SRC

And =Invoke-Expression= to call the scoop installer with the array

#+BEGIN_SRC powershell
Invoke-Expression "scoop install $propositumComponents"
#+END_SRC
** Install & setup =doom-emacs=
:PROPERTIES:
:ID:       4BCE227D-7309-4E0E-BF45-F00C0E4BD769
:END:

Save the current path & navigate to the =$propositum.home= folder

#+BEGIN_SRC powershell
Push-Location $propositum.home
#+END_SRC

Clone the =doom-emacs= repo as our =.emacs.d= folder and switch to the =develop= branch (=master= is out-of-date)

#+BEGIN_SRC powershell
git clone https://github.com/hlissner/doom-emacs .emacs.d; cd .emacs.d; git checkout develop
#+END_SRC

Add the =doom-emacs= binaries folder to =path=

#+NAME: doom-bin-to-path
#+BEGIN_SRC powershell
$doomBin = $propositum.home + "\.emacs.d\bin"
$env:Path = $env:Path + ";" + $doomBin
#+END_SRC

Then =doom quickstart= to install packages for a basic configuration (at least
until my custom one is ready).

=-y= accepts all prompts to prevent AppVeyor build from hanging.

#+BEGIN_SRC powershell
doom -y quickstart
#+END_SRC

Return to the original path

#+BEGIN_SRC powershell
Pop-Location
#+END_SRC
** Clean-up

Post-installation clean-up, primarily to reduce the overall size of the final
build artifact.
*** Delete scoop cache
:PROPERTIES:
:ID:       37614274-E067-4FFA-9BD0-83FFB0264075
:END:

#+BEGIN_SRC powershell
scoop cache rm *
#+END_SRC
** Summarise Installation
*** Summarise via Scoop
:PROPERTIES:
:ID:       AB7C1777-8F53-41DF-A99E-E5285BB36D68
:END:

Provide the user a summary of what was installed (including any dependencies installed automatically)

#+BEGIN_SRC powershell
scoop list | Write-Host
#+END_SRC

Generate a list of the applications & versions installed and store in a text file. This can be used as a reference of what was installed & also as an importable 'install' file for Scoop.

#+BEGIN_SRC powershell
  Push-Location $propositum.apps
  scoop export | Out-String > install-info.txt
  Pop-Location
#+END_SRC
** Create build artifact
:PROPERTIES:
:ID:       0AC1E5F5-D4EE-40F5-ACF3-D7D6C26DC59E
:END:

Create the 7zip'd build artifact with high compression for later deployment - this is the file unzipped on systems which require an 'offline' install (i.e. no access to external package repositories).

We only need to do this if running on AppVeyor.

#+BEGIN_SRC powershell
if ($buildPlatform -eq "appveyor")
{
    echo "Compressing files into release artifact..."
    cd $propositum.root # cd to root, as 7z -v switch does not support specifying end file and directory 
    echo "Creating TAR archive..."
    iex "7z a -ttar -snl propositum.tar P:\" # Create tar archive to preserve symlinks
    echo "Compressing TAR into 7z archive..."
    iex "7z a -t7z propositum.tar.7z propositum.tar -m0=lzma -mx=9 -mfb=64 -md=32m -ms=on -v1500m" # Compress tar into 7z archive 
#+END_SRC
*** BinTray Deployment
#+BEGIN_SRC powershell
    # Workaround for AppVeyor BinTray issue (only accepts .zip archives)
    if ($bintrayDeploy)
    {
    iex -verbose "7z a propositum.zip propositum.tar.7z*"
    }

}
#+END_SRC

Due to limitations with =BinTray= uploads, if ~binTrayDeploy~ is set to =Yes= we
should additionally put the artifact into a zip for upload.
* Deploy

Deploy the latest =propositum= release to the platform of choice.
** Only attempt to deploy if the ~$buildPlatform~ is AppVeyor
:PROPERTIES:
:ID:       1386CD2A-F620-4C8C-968A-EFD58840D0C4
:END:

#+BEGIN_SRC powershell
  if ($buildPlatform -eq "appveyor") {$deploy = $true}
  else {$deploy = $false}
#+END_SRC
* Upgrade
:PROPERTIES:
:header-args: :tangle propositum-upgrade.ps1
:END:

Upgrade an existing instance of =propositum=

*TODO List*

- [ ] tangles as a separate file =propositum-upgrade.ps1=
- [ ] should include the =propositum-helper-fns.ps1=
- [ ] should be able to run as a local user (not an admin)
- [ ] should be able to take the latest propositum artifact release as an input
- [ ] should have a separate function that just updates configs (or perhaps a separate release that is just the config info? e.g. updated .doom.d config file)
* Finish
General clean-up and post-installation activities.
** Generate post-install script
:PROPERTIES:
:header-args: :tangle propositum-post-install.ps1
:ID:       92FEC991-0504-4E1D-8407-F22D12791562
:END:

These are variables or commands that need to be set again post-installation. Note that we use org-babel's =<<NOWEB>>= syntax here to import the variables from wherever they are defined.

This section has a =:PROPERTIES:= section that tangles to =propositum-post-install.ps1= allowing that file to be included e.g. as a script upon launch of cmder (or just run as a one-off).

#+BEGIN_SRC powershell :noweb yes
<<set-build-platform>>
<<collect-platform-vars>>
<<set-platform-vars>>
<<collect-other-vars>>
<<set-other-vars>>
<<set-scoop-env-var>>
<<map-propositum-drv>>
reg add HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /f /v "Propositum" /d "subst $propositumDrv $propositumLocation" # Add registry entry to map on startup
<<propositum-components-list>> 
$env:Path = $env:Path + ";" + "$propositum.root\shims"  # Add shims to path again so scoop & other commands available on command line
<<doom-bin-to-path>>
iex "scoop reset *" # Re-enables all scoop apps
#+END_SRC

For completeness, here is a script to remove the reigstry key added for mapping
the propositum drive on startup

#+BEGIN_SRC powershell :tangle propositum-remove-drv-startup.ps1
reg delete HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /f /v "Propositum" # Removes the registry entry to map propositum drive on startup
#+END_SRC
* Archived
The code & sub-sections below have been archived as they are no longer in-use.
